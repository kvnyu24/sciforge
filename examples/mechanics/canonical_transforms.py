"""
Experiment 63: Canonical Transformations.

Demonstrates canonical (symplectic) transformations that preserve
the structure of Hamilton's equations and Poisson brackets.

Key concepts:
1. Generating functions for canonical transformations
2. Preservation of Poisson bracket structure: {Q, P} = 1
3. Examples: rotation in phase space, point transformations
4. Symplectic condition: M^T J M = J

Canonical transformations are the backbone of advanced mechanics,
connecting different formulations and simplifying problems.
"""

import sys
import os
sys.path.append(os.path.dirname(os.path.dirname(os.path.dirname(__file__))))

import numpy as np
import matplotlib.pyplot as plt


def poisson_bracket(f, g, state, h=1e-7):
    """
    Compute Poisson bracket {f, g} for a 1-DOF system.

    {f, g} = df/dq * dg/dp - df/dp * dg/dq
    """
    q, p = state

    # Numerical derivatives
    df_dq = (f(np.array([q+h, p])) - f(np.array([q-h, p]))) / (2*h)
    df_dp = (f(np.array([q, p+h])) - f(np.array([q, p-h]))) / (2*h)
    dg_dq = (g(np.array([q+h, p])) - g(np.array([q-h, p]))) / (2*h)
    dg_dp = (g(np.array([q, p+h])) - g(np.array([q, p-h]))) / (2*h)

    return df_dq * dg_dp - df_dp * dg_dq


def check_symplectic(M):
    """
    Check if matrix M satisfies the symplectic condition.

    M is symplectic if M^T J M = J where J = [[0, 1], [-1, 0]]

    Returns:
        True if symplectic, False otherwise
    """
    n = M.shape[0] // 2
    J = np.block([
        [np.zeros((n, n)), np.eye(n)],
        [-np.eye(n), np.zeros((n, n))]
    ])

    result = M.T @ J @ M
    return np.allclose(result, J)


# --- Generating Functions and Transformations ---

def type1_generating_function(F1, q, P, h=1e-7):
    """
    Type 1 generating function F1(q, Q).

    Relations:
        p = dF1/dq
        P = -dF1/dQ

    Here we're given F1(q, Q) but need to find Q from P.
    This is typically solved implicitly.
    """
    # Numerical derivative dF1/dQ at fixed q
    dF1_dQ = lambda Q: (F1(q, Q+h) - F1(q, Q-h)) / (2*h)
    # Need to solve -dF1/dQ = P for Q
    # Use Newton's method
    Q = q  # Initial guess
    for _ in range(20):
        f_val = -dF1_dQ(Q) - P
        # Derivative: -d^2F1/dQ^2
        f_prime = -(F1(q, Q+h) - 2*F1(q, Q) + F1(q, Q-h)) / h**2
        if abs(f_prime) > 1e-10:
            Q = Q - f_val / f_prime
        if abs(f_val) < 1e-10:
            break
    return Q


def type2_generating_function_transform(F2, q, p, h=1e-7):
    """
    Type 2 generating function F2(q, P) -> (Q, P).

    Relations:
        p = dF2/dq
        Q = dF2/dP

    Given (q, p), find (Q, P):
    1. Solve p = dF2/dq|_P for P (implicit)
    2. Then Q = dF2/dP

    For simplicity, we'll work with specific examples.
    """
    pass


# --- Specific Canonical Transformations ---

def rotation_transform(q, p, theta):
    """
    Rotation in phase space by angle theta.

    Q = q*cos(theta) + p*sin(theta)
    P = -q*sin(theta) + p*cos(theta)

    This is canonical (area-preserving).
    """
    Q = q * np.cos(theta) + p * np.sin(theta)
    P = -q * np.sin(theta) + p * np.cos(theta)
    return Q, P


def rotation_matrix(theta):
    """Rotation matrix in phase space."""
    return np.array([
        [np.cos(theta), np.sin(theta)],
        [-np.sin(theta), np.cos(theta)]
    ])


def scaling_transform(q, p, alpha):
    """
    Scaling transformation.

    Q = alpha * q
    P = p / alpha

    This preserves phase space area (canonical).
    """
    Q = alpha * q
    P = p / alpha
    return Q, P


def scaling_matrix(alpha):
    """Scaling transformation matrix."""
    return np.array([
        [alpha, 0],
        [0, 1/alpha]
    ])


def exchange_transform(q, p):
    """
    Exchange coordinates and momenta.

    Q = p
    P = -q

    This is canonical.
    """
    return p, -q


def shear_transform(q, p, s):
    """
    Shear transformation.

    Q = q + s*p
    P = p

    This is canonical (generated by F2 = qP + (s/2)P^2).
    """
    Q = q + s * p
    P = p
    return Q, P


def time_evolution_transform(q, p, H, dt, m=1.0, k=1.0):
    """
    Time evolution as a canonical transformation.

    For SHO, one period is a canonical transformation
    back to the starting point (identity).
    """
    omega = np.sqrt(k / m)

    # For SHO: exact solution
    Q = q * np.cos(omega * dt) + (p / (m * omega)) * np.sin(omega * dt)
    P = p * np.cos(omega * dt) - m * omega * q * np.sin(omega * dt)

    return Q, P


def main():
    fig = plt.figure(figsize=(16, 12))

    # --- Plot 1: Rotation in phase space ---
    ax1 = fig.add_subplot(2, 3, 1)

    # Initial phase space region (a square)
    n_points = 20
    q_init = np.linspace(-1, 1, n_points)
    p_init = np.linspace(-1, 1, n_points)
    Q_grid, P_grid = np.meshgrid(q_init, p_init)
    q_flat = Q_grid.flatten()
    p_flat = P_grid.flatten()

    ax1.scatter(q_flat, p_flat, c='blue', s=10, alpha=0.5, label='Original')

    # Apply rotation
    theta = np.pi / 4  # 45 degrees
    Q_rot, P_rot = rotation_transform(q_flat, p_flat, theta)

    ax1.scatter(Q_rot, P_rot, c='red', s=10, alpha=0.5, label=f'Rotated {np.degrees(theta):.0f} deg')

    ax1.set_xlabel('q / Q')
    ax1.set_ylabel('p / P')
    ax1.set_title('Rotation in Phase Space\nQ = q*cos(theta) + p*sin(theta)')
    ax1.legend()
    ax1.set_aspect('equal')
    ax1.grid(True, alpha=0.3)

    # Verify symplectic
    M_rot = rotation_matrix(theta)
    is_symp = check_symplectic(M_rot)
    ax1.text(0.05, 0.95, f'Symplectic: {is_symp}', transform=ax1.transAxes,
             fontsize=10, verticalalignment='top')

    # --- Plot 2: Scaling transformation ---
    ax2 = fig.add_subplot(2, 3, 2)

    ax2.scatter(q_flat, p_flat, c='blue', s=10, alpha=0.5, label='Original')

    # Apply scaling
    alpha = 2.0
    Q_scale, P_scale = scaling_transform(q_flat, p_flat, alpha)

    ax2.scatter(Q_scale, P_scale, c='green', s=10, alpha=0.5,
                label=f'Scaled (alpha={alpha})')

    ax2.set_xlabel('q / Q')
    ax2.set_ylabel('p / P')
    ax2.set_title('Scaling Transformation\nQ = alpha*q, P = p/alpha')
    ax2.legend()
    ax2.set_aspect('equal')
    ax2.grid(True, alpha=0.3)

    # Verify symplectic
    M_scale = scaling_matrix(alpha)
    is_symp = check_symplectic(M_scale)
    ax2.text(0.05, 0.95, f'Symplectic: {is_symp}', transform=ax2.transAxes,
             fontsize=10, verticalalignment='top')

    # Calculate areas
    original_area = 4.0  # 2x2 square
    ax2.text(0.05, 0.85, f'Area preserved: q*p = Q*P', transform=ax2.transAxes,
             fontsize=9, verticalalignment='top')

    # --- Plot 3: Time evolution as canonical transformation ---
    ax3 = fig.add_subplot(2, 3, 3)

    # For SHO, trace evolution of phase space region
    m, k = 1.0, 1.0
    omega = np.sqrt(k / m)
    period = 2 * np.pi / omega

    # Initial region: small disk
    theta_circle = np.linspace(0, 2*np.pi, 50)
    r = 0.3
    q0_circle = 1.0 + r * np.cos(theta_circle)
    p0_circle = 0.5 + r * np.sin(theta_circle)

    colors = plt.cm.viridis(np.linspace(0, 1, 5))
    times_plot = [0, period/4, period/2, 3*period/4, period]

    for t, color in zip(times_plot, colors):
        Q_t, P_t = time_evolution_transform(q0_circle, p0_circle, None, t, m, k)
        ax3.fill(Q_t, P_t, alpha=0.3, color=color, label=f't = {t/period:.2f}T')
        ax3.plot(Q_t, P_t, color=color, lw=1)

    ax3.set_xlabel('q')
    ax3.set_ylabel('p')
    ax3.set_title('Time Evolution = Canonical Transform\n(SHO: shape preserved, rotates)')
    ax3.legend(fontsize=8)
    ax3.set_aspect('equal')
    ax3.grid(True, alpha=0.3)

    # --- Plot 4: Verify Poisson bracket preservation ---
    ax4 = fig.add_subplot(2, 3, 4)

    # Test that {Q, P} = 1 after transformation
    test_points = [
        (1.0, 0.5),
        (-0.5, 1.0),
        (2.0, -1.0),
        (-1.0, -2.0),
    ]

    transformations = [
        ('Rotation 30 deg', lambda q, p: rotation_transform(q, p, np.radians(30))),
        ('Scaling x2', lambda q, p: scaling_transform(q, p, 2.0)),
        ('Exchange', lambda q, p: exchange_transform(q, p)),
        ('Shear s=0.5', lambda q, p: shear_transform(q, p, 0.5)),
    ]

    bracket_values = []
    labels = []

    for trans_name, trans_func in transformations:
        for q, p in test_points:
            Q, P = trans_func(q, p)

            # Define Q and P as functions of original (q, p)
            def Q_func(state):
                q_in, p_in = state
                Q_out, _ = trans_func(q_in, p_in)
                return Q_out

            def P_func(state):
                q_in, p_in = state
                _, P_out = trans_func(q_in, p_in)
                return P_out

            bracket = poisson_bracket(Q_func, P_func, np.array([q, p]))
            bracket_values.append(bracket)
            labels.append(f'{trans_name}\n({q:.1f},{p:.1f})')

    x_pos = np.arange(len(bracket_values))
    bars = ax4.bar(x_pos, bracket_values, color='steelblue', alpha=0.7)

    ax4.axhline(1.0, color='red', linestyle='--', lw=2, label='Expected: {Q,P}=1')
    ax4.set_xticks(x_pos[::4])
    ax4.set_xticklabels([t[0] for t in transformations], rotation=45, ha='right')
    ax4.set_ylabel('{Q, P}')
    ax4.set_title('Poisson Bracket Preservation\nCanonical transforms: {Q, P} = 1')
    ax4.legend()
    ax4.grid(True, alpha=0.3, axis='y')
    ax4.set_ylim(0.9, 1.1)

    # --- Plot 5: Composition of transformations ---
    ax5 = fig.add_subplot(2, 3, 5)

    # Start with a region
    q_square = np.array([0, 1, 1, 0, 0])
    p_square = np.array([0, 0, 1, 1, 0])

    ax5.fill(q_square, p_square, alpha=0.3, color='blue', label='Original')
    ax5.plot(q_square, p_square, 'b-', lw=2)

    # Apply sequence: rotate -> scale -> shear
    Q1, P1 = rotation_transform(q_square, p_square, np.radians(30))
    Q2, P2 = scaling_transform(Q1, P1, 1.5)
    Q3, P3 = shear_transform(Q2, P2, 0.3)

    ax5.fill(Q1, P1, alpha=0.2, color='green', label='After rotation')
    ax5.fill(Q2, P2, alpha=0.2, color='orange', label='After scaling')
    ax5.fill(Q3, P3, alpha=0.3, color='red', label='After shear')
    ax5.plot(Q3, P3, 'r-', lw=2)

    ax5.set_xlabel('q / Q')
    ax5.set_ylabel('p / P')
    ax5.set_title('Composition of Canonical Transforms\n(Area always preserved)')
    ax5.legend(fontsize=8)
    ax5.grid(True, alpha=0.3)

    # Calculate areas
    def polygon_area(x, y):
        return 0.5 * abs(np.sum(x[:-1]*y[1:] - x[1:]*y[:-1]))

    area_original = polygon_area(q_square, p_square)
    area_final = polygon_area(Q3, P3)
    ax5.text(0.05, 0.95, f'Original area: {area_original:.2f}\nFinal area: {area_final:.2f}',
             transform=ax5.transAxes, fontsize=10, verticalalignment='top')

    # --- Plot 6: Theory summary ---
    ax6 = fig.add_subplot(2, 3, 6)
    ax6.axis('off')

    summary = """Canonical (Symplectic) Transformations
======================================

A transformation (q, p) -> (Q, P) is CANONICAL if
it preserves the form of Hamilton's equations.

GENERATING FUNCTIONS:
---------------------
Type 1: F1(q, Q)    p = dF1/dq,   P = -dF1/dQ
Type 2: F2(q, P)    p = dF2/dq,   Q = dF2/dP
Type 3: F3(p, Q)    q = -dF3/dp,  P = -dF3/dQ
Type 4: F4(p, P)    q = -dF4/dp,  Q = dF4/dP

SYMPLECTIC CONDITION:
---------------------
Matrix form: M^T J M = J

where J = | 0   I |
          |-I   0 |

Equivalent to: det(M) = 1 and area preserved.

POISSON BRACKET PRESERVATION:
-----------------------------
{Q, P} = 1  (fundamental bracket)
{f, g} is the same in old or new coordinates.

IMPORTANT EXAMPLES:
-------------------
1. Rotation:  Q = q*cos(t) + p*sin(t)
              P = -q*sin(t) + p*cos(t)

2. Scaling:   Q = a*q,  P = p/a

3. Exchange:  Q = p,    P = -q
   (Generated by F1 = q*Q)

4. Time evolution (if H is autonomous)

APPLICATIONS:
-------------
- Simplify Hamiltonian problems
- Action-angle variables
- Perturbation theory
- Quantum mechanics (unitary = canonical)
- Symplectic integrators"""

    ax6.text(0.02, 0.98, summary, transform=ax6.transAxes, fontsize=9,
             verticalalignment='top', fontfamily='monospace',
             bbox=dict(boxstyle='round', facecolor='lightcyan', alpha=0.8))

    plt.suptitle('Canonical Transformations (Experiment 63)',
                 fontsize=14, y=1.02)
    plt.tight_layout()

    # Save
    output_dir = os.path.join(os.path.dirname(os.path.dirname(__file__)), 'output')
    os.makedirs(output_dir, exist_ok=True)
    output_path = os.path.join(output_dir, 'canonical_transforms.png')
    plt.savefig(output_path, dpi=150, bbox_inches='tight')
    print(f"Saved to {output_path}")

    # Print verification
    print("\nCanonical Transformation Verification:")
    print("-" * 50)

    print("\nSymplectic condition M^T J M = J:")
    for name, matrix_func in [
        ('Rotation 45 deg', lambda: rotation_matrix(np.radians(45))),
        ('Scaling x2', lambda: scaling_matrix(2.0)),
        ('Shear s=0.5', lambda: np.array([[1, 0.5], [0, 1]])),
    ]:
        M = matrix_func()
        print(f"  {name}: symplectic = {check_symplectic(M)}")

    print("\nPoisson bracket {Q, P} after transformation:")
    for trans_name, trans_func in transformations:
        def Q_func(state):
            Q_out, _ = trans_func(state[0], state[1])
            return Q_out

        def P_func(state):
            _, P_out = trans_func(state[0], state[1])
            return P_out

        bracket = poisson_bracket(Q_func, P_func, np.array([1.0, 0.5]))
        print(f"  {trans_name}: {{Q, P}} = {bracket:.6f}")


if __name__ == "__main__":
    main()
